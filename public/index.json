[{"content":"What is NGINX? NGINX is a versatile tool that functions as an HTTP web server, reverse proxy, content cache, load balancer, TCP/UDP proxy server, and mail proxy server. In this blog, we’ll focus on using NGINX as a load balancer for a static web server application.\nOverview of the Setup In this tutorial, we’ll walk through setting up a load-balanced environment for a simple static web page server using Spring Boot, Docker, and NGINX. Here\u0026rsquo;s the high-level workflow:\nStatic Web Server App:\nA Spring Boot application will automatically serve static HTML files placed in its /static directory.\nDocker:\nWe’ll use Docker to run multiple instances of the Spring Boot app on different ports via a docker-compose file.\nConfiguring NGINX:\nNGINX will be configured to distribute incoming traffic across the multiple app instances, acting as the load balancer.\n1. Building the Static Web Server App Let’s create a simple Spring Boot application that serves static HTML files:\nPlace your HTML files in the src/main/resources/static/ directory of your Spring Boot project. Run the Spring Boot application. By default, it serves the static files at http://localhost:8080. 2. Dockerizing the Application To scale the Spring Boot application, we’ll containerize it using Docker. Here’s a basic Dockerfile for the app:\nFROM openjdk:17-jdk-slim COPY target/static-web-app.jar app.jar ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;/app.jar\u0026#34;]``` Build the docker image : ```bash docker build -t static-web-app . Create a docker-compose.yml file to run containers of the same app on multiple ports. We will create 3 instances of the container and bind them to ports 3001, 3002 and 3003 respectively.\nservices: app1: build: . environment: - APP_NAME=App1 ports: - 3001:8080 app2: build: . environment: - APP_NAME=App2 ports: - 3002:8080 app3: build: . environment: - APP_NAME=App3 ports: - 3003:8080 Run the docker-compose.yml file :\ndocker-compose up --build --build parameter will rebuild the docker image. At this point, the web page should be accessible at localhost:300x ports. Now we need to set up nginx to distribute traffic across these apps.\n3. Configuring NGINX Install nginx using your package manager. To configure nginx, we need to edit the file nginx.conf which you can locate using the command:\nnginx -t Here\u0026rsquo;s a basic NGINX config file to balance traffic between app instances:\nworker_processes 1; # Defines the number of worker processes nginx uses # Set to 1 for low-traffic environments events { worker_connections 1024; # This defines the number of simultaneous connections # each worker process can have } http { upstream spring_cluster { # Defines load balancing group name. least_conn; # By default nginx uses round-robin. We use least_conn. server 127.0.0.1:3001; server 127.0.0.1:3002; server 127.0.0.1:3003; } server { # handles logic for routing requests. listen 80; # Port on which nginx listens to for HTTP requests server_name localhost; # Defines what to do when the `/` location is accessed location / { proxy_pass http://spring_cluster; # forwards the request to the cluster proxy_set_header Host $host; # passes the Host header to the upstream server proxy_set_header X-Real-IP $remote_addr; # passes client IP address to server. } } } Test config file using:\nnginx -t Reload nginx to apply new config :\nnginx -s reload Access your application via the NGINX load balancer at http://localhost:80. Log the app name in the Spring Boot app to confirm that resources are being distributed.\n","permalink":"/posts/nginx-as-a-load-balancer/","summary":"\u003ch2 id=\"what-is-nginx\"\u003eWhat is NGINX?\u003c/h2\u003e\n\u003cp\u003eNGINX is a versatile tool that functions as an HTTP web server, reverse proxy, content cache, load balancer, TCP/UDP proxy server, and mail proxy server. In this blog, we’ll focus on using NGINX as a \u003cstrong\u003eload balancer\u003c/strong\u003e for a static web server application.\u003c/p\u003e\n\u003ch3 id=\"overview-of-the-setup\"\u003eOverview of the Setup\u003c/h3\u003e\n\u003cp\u003eIn this tutorial, we’ll walk through setting up a load-balanced environment for a simple static web page server using \u003cstrong\u003eSpring Boot\u003c/strong\u003e, \u003cstrong\u003eDocker\u003c/strong\u003e, and \u003cstrong\u003eNGINX\u003c/strong\u003e. Here\u0026rsquo;s the high-level workflow:\u003c/p\u003e","title":"Using NGINX as a Load Balancer"},{"content":"Hi! I’m Athul V Anil, a software developer who enjoys creating efficient and intuitive solutions. I’m particularly passionate about using tools like Java, Spring Boot, and AWS to build practical applications and explore innovative approaches, like integrating AI into development workflows.\nI love collaborating with others to solve challenging problems and continuously learning about new technologies. Outside of work, I enjoy participating in hackathons, gaming, and playing the guitar. These hobbies fuel my creativity and keep me inspired!\nFeel free to connect—I’m always up for a good tech chat or collaboration!\n","permalink":"/about/about-me/","summary":"\u003cp\u003eHi! I’m \u003cstrong\u003eAthul V Anil\u003c/strong\u003e, a software developer who enjoys creating efficient and intuitive solutions. I’m particularly passionate about using tools like \u003cstrong\u003eJava\u003c/strong\u003e, \u003cstrong\u003eSpring Boot\u003c/strong\u003e, and \u003cstrong\u003eAWS\u003c/strong\u003e to build practical applications and explore innovative approaches, like integrating \u003cstrong\u003eAI\u003c/strong\u003e into development workflows.\u003c/p\u003e\n\u003cp\u003eI love collaborating with others to solve challenging problems and continuously learning about new technologies. Outside of work, I enjoy participating in hackathons, gaming, and playing the guitar. These hobbies fuel my creativity and keep me inspired!\u003c/p\u003e","title":"About Me"},{"content":"Here\u0026rsquo;s how I manage and run this blog:\nObsidian\nObsidian is my go-to note-taking and writing tool. I use it to draft, organize, and refine all my posts before publishing. Its markdown-based workflow is perfect for my use case such as this website.\nHugo\nHugo is the static site generator powering this blog. It allows me to convert markdown files into a fast and beautifully designed website with ease.\nGitHub\nGitHub serves as my version control and deployment tool. I push my Hugo-generated website to a GitHub repository, which keeps my code and content organized and backed up.\nPrivate Server on Oracle Cloud\nI host my website on a free private server provisioned through Oracle Cloud. I like hosting my own websites. I am also hosting this website on Github pages.\nWith this setup, I can write in Obsidian, use Hugo to generate the site, manage my source code with GitHub, and host it securely on my Oracle Cloud server. This pipeline ensures a smooth and efficient workflow for maintaining this blog.\nSetting up Hugo 1. Installation On Windows: Download the Hugo executable from the official website. Add the Hugo binary to your system\u0026rsquo;s PATH variable, so you can run it from the command line. Verify the installation by running hugo version in your terminal. On Mac: Use Homebrew to install Hugo by running the following command: brew install hugo On Linux: Install using your package manager: sudo apt-get install hugo Verify installation by running hugo version 2. Creating a Hugo Website After Hugo is installed, create a new website using the command:\nhugo new site website_name This creates a new Hugo site in the website_name folder.\n3. Downloading Hugo Themes Browse official Hugo themes site for customizing the look of the website. To install a theme:\nNavigate to the website folder: cd website_name Download your desired theme into the themes directory. In my case, I used: git init git submodule add https://github.com/LordMathis/hugo-theme-nightfall themes/nightfall 4. Setting up hugo.toml hugo.toml is the configuration file for your hugo website. It is where you need to set the global parameters such as title, language, theme etc. You can find more about this in the theme\u0026rsquo;s documentation.\n5. Creating the blog folder inside content Hugo uses a folder structure to organize the website content. You need to create a folder to hold the markdown file that you need to convert into a website page.\ncd content mkdir blog 6. Copy markdown files from Obsidian folder to content/blog You will need to copy the markdown files from the Obsidian folder to the content/blog folder so Hugo can convert it into webpages.\nRun the commands replacing the directories with the source directory and destination directory respectively:\nOn Windows : robocopy \\path\\to\\obsidian\\folder \\path\\to\\content\\blog /E On Linux : rsync -av --progress /path/to/obsidian/ /path/to/website_name/content/blog/ Note: You can find the directory of the obsidian folder by right clicking on the folder inside Obsidian and clicking \u0026ldquo;Show in folder\u0026rdquo;.\n7. Building the website Once you have your markdown content ready and copied over to the content/blog folder:\nBuild website using:\nhugo Start the development server in your browser using:\nhugo server Your website will be available at http://localhost:1313/.\n8. Publishing the website You can use Github pages or deploy to your own server or even a hosting provider.\nUsing Github Pages:\nPush Hugo generated static files (found in public/) directory to your Github repo. Set up Github pages to serve content from the public directory. For a private server:\nTransfer the public folder contents to your server. Serve the files using a web server like Nginx or Apache. Note: For a more efficient workflow, automate rsync/robocopy, hugo, hugo server using a powershell/bash script.\n","permalink":"/posts/my-blog-pipeline/","summary":"\u003cp\u003eHere\u0026rsquo;s how I manage and run this blog:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://obsidian.md\"\u003eObsidian\u003c/a\u003e\u003c/strong\u003e\u003cbr\u003e\nObsidian is my go-to note-taking and writing tool. I use it to draft, organize, and refine all my posts before publishing. Its markdown-based workflow is perfect for my use case such as this website.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://gohugo.io\"\u003eHugo\u003c/a\u003e\u003c/strong\u003e\u003cbr\u003e\nHugo is the static site generator powering this blog. It allows me to convert markdown files into a fast and beautifully designed website with ease.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com\"\u003eGitHub\u003c/a\u003e\u003c/strong\u003e\u003cbr\u003e\nGitHub serves as my version control and deployment tool. I push my Hugo-generated website to a GitHub repository, which keeps my code and content organized and backed up.\u003c/p\u003e","title":"My Blog Pipeline"}]